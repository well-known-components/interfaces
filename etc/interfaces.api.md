## API Report File for "@well-known-components/interfaces"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type * as fetch_2 from 'node-fetch';
import type { ParseUrlParams } from 'typed-url-params';
import type * as stream from 'stream';

// @public
export type IAdapterHandler<Context, ReturnType> = (context: Context) => Promise<ReturnType>;

// @public (undocumented)
export namespace IBaseComponent {
    // (undocumented)
    export type ComponentStartOptions = {
        started(): boolean;
        live(): boolean;
        getComponents(): Record<string, any>;
    };
}

// @public
export interface IBaseComponent {
    start?: (startOptions: IBaseComponent.ComponentStartOptions) => Promise<void>;
    stop?: () => Promise<void>;
}

// @public
export interface ICacheComponent {
    get(key: string): Promise<ArrayBuffer | null>;
    put(key: string, value: string | ArrayBuffer): Promise<void>;
}

// @public (undocumented)
export interface IConfigComponent {
    // (undocumented)
    getNumber(name: string): Promise<number | undefined>;
    // (undocumented)
    getString(name: string): Promise<string | undefined>;
    // (undocumented)
    requireNumber(name: string): Promise<number>;
    // (undocumented)
    requireString(name: string): Promise<string>;
}

// @public (undocumented)
export namespace IDatabase {
    // (undocumented)
    export interface IQueryResult<T extends Record<string, any>> {
        // (undocumented)
        rowCount: number;
        // (undocumented)
        rows: T[];
    }
}

// @public
export interface IDatabase {
    // (undocumented)
    query<T>(sql: string): Promise<IDatabase.IQueryResult<T>>;
}

// @alpha (undocumented)
export namespace IHttpServerComponent {
    // (undocumented)
    export type DefaultContext<Context = {}> = Context & {
        request: IRequest;
        url: URL;
    };
    // @public
    export type HTTPMethod =
    /**
     * The `CONNECT` method establishes a tunnel to the server identified by the
     * target resource.
     */
    "CONNECT"
    /**
     * The `DELETE` method deletes the specified resource.
     */
     | "DELETE"
    /**
     * The `GET` method requests a representation of the specified resource.
     * Requests using GET should only retrieve data.
     */
     | "GET"
    /**
     * The `HEAD` method asks for a response identical to that of a GET request,
     * but without the response body.
     */
     | "HEAD"
    /**
     * The `OPTIONS` method is used to describe the communication options for the
     * target resource.
     */
     | "OPTIONS"
    /**
     * The PATCH method is used to apply partial modifications to a resource.
     */
     | "PATCH"
    /**
     * The `POST` method is used to submit an entity to the specified resource,
     * often causing a change in state or side effects on the server.
     */
     | "POST"
    /**
     * The `PUT` method replaces all current representations of the target
     * resource with the request payload.
     */
     | "PUT"
    /**
     * The `TRACE` method performs a message loop-back test along the path to the
     * target resource.
     */
     | "TRACE";
    // (undocumented)
    export type IRequest = fetch_2.Request;
    // (undocumented)
    export type IRequestHandler<Context = {}> = IMiddlewareAdapterHandler<DefaultContext<Context>, IResponse>;
    // (undocumented)
    export type IResponse = ResponseInit & {
        body?: ResponseBody;
    };
    // (undocumented)
    export type JsonBody = Record<string, any>;
    // (undocumented)
    export type MethodHandlers<Context> = {
        [key in Lowercase<HTTPMethod>]: PathAwareHandler<Context>;
    };
    // (undocumented)
    export type ParseUrlParams<State extends string, Memo extends Record<string, any> = {}> = ParseUrlParams<State, Memo>;
    // (undocumented)
    export type PathAwareContext<Context = {}, Path extends string = string> = Context & {
        params: string extends Path ? any : IHttpServerComponent.ParseUrlParams<Path>;
    };
    // (undocumented)
    export interface PathAwareHandler<Context> {
        // (undocumented)
        <Path extends string>(
        path: Path,
        handler: IHttpServerComponent.IRequestHandler<PathAwareContext<Context, Path>>): void;
    }
    // (undocumented)
    export type QueryParams = Record<string, any>;
    // (undocumented)
    export type ResponseBody = JsonBody | stream.Readable | Uint8Array | Buffer | string;
    // (undocumented)
    export type UrlParams = Record<string, string | string[]>;
}

// @alpha (undocumented)
export interface IHttpServerComponent<Context extends object> {
    setContext(ctx: Context): void;
    use: (
    handler: IHttpServerComponent.IRequestHandler<Context>) => void;
}

// @public (undocumented)
export namespace ILoggerComponent {
    // (undocumented)
    export type ILogger = {
        log(message: string, extra?: Record<string, string | number>): void;
        error(error: string | Error, extra?: Record<string, string | number>): void;
        debug(message: string, extra?: Record<string, string | number>): void;
        info(message: string, extra?: Record<string, string | number>): void;
        warn(message: string, extra?: Record<string, string | number>): void;
    };
}

// @public (undocumented)
export type ILoggerComponent = {
    getLogger(loggerName: string): ILoggerComponent.ILogger;
};

// @public (undocumented)
export namespace IMetricsComponent {
    // (undocumented)
    export type CounterMetricDefinition = {
        type: CounterType;
        help: string;
        labelNames?: string[] | readonly string[];
    };
    // (undocumented)
    export type CounterType = "counter";
    // (undocumented)
    export type ExportedMetricData = {
        help: string;
        name: string;
        type: MetricDefinition["type"];
        values: any[];
        aggregator: string;
    };
    // (undocumented)
    export type GaugeMetricDefinition = {
        type: GaugeType;
        help: string;
        labelNames?: string[] | readonly string[];
    };
    const // (undocumented)
    GaugeType: GaugeType;
    const // (undocumented)
    CounterType: CounterType;
    const // (undocumented)
    HistogramType: HistogramType;
    const // (undocumented)
    SummaryType: SummaryType;
    // (undocumented)
    export type GaugeType = "gauge";
    // (undocumented)
    export type HistogramMetricDefinition = {
        type: HistogramType;
        help: string;
        labelNames?: string[] | readonly string[];
        buckets?: number[];
    };
    // (undocumented)
    export type HistogramType = "histogram";
    // (undocumented)
    export type Labels = Record<string, string | number>;
    // (undocumented)
    export type MetricDefinition = GaugeMetricDefinition | CounterMetricDefinition | HistogramMetricDefinition | SummaryMetricDefinition;
    // (undocumented)
    export type MetricsRecordDefinition<K extends string> = Record<K, MetricDefinition>;
    // (undocumented)
    export type SummaryMetricDefinition = {
        type: SummaryType;
        help: string;
        labelNames?: string[] | readonly string[];
        percentiles?: number[];
        maxAgeSeconds?: number;
        ageBuckets?: number;
        compressCount?: number;
    };
    // (undocumented)
    export type SummaryType = "summary";
}

// @public (undocumented)
export interface IMetricsComponent<K extends string> {
    decrement(metricName: K, labels?: IMetricsComponent.Labels, value?: number): void;
    getValue(metricName: K): Promise<IMetricsComponent.ExportedMetricData>;
    increment(metricName: K, labels?: IMetricsComponent.Labels, value?: number): void;
    observe(metricName: K, labels: IMetricsComponent.Labels, value: number): void;
    reset(metricName: K): void;
    resetAll(): void;
    startTimer(metricName: K, labels?: IMetricsComponent.Labels): {
        end: (endLabels?: IMetricsComponent.Labels) => void;
    };
}

// @public
export type IMiddlewareAdapterHandler<Context, ReturnType> = (context: Context, next: () => Promise<ReturnType>) => Promise<ReturnType>;

// @beta (undocumented)
export namespace IRolloutComponent {
    // (undocumented)
    export type FallbackFunction = (name: string, context: RolloutContext) => boolean;
    // (undocumented)
    export interface Override {
        // (undocumented)
        contextName: string;
        // (undocumented)
        values: String[];
    }
    // (undocumented)
    export interface Payload {
        // (undocumented)
        type: PayloadType;
        // (undocumented)
        value: string;
    }
    // (undocumented)
    export enum PayloadType {
        // (undocumented)
        STRING = "string"
    }
    // (undocumented)
    export type RolloutContext = {
        userId?: string;
        sessionId?: string;
        remoteAddress?: string;
        environment?: string;
        appName?: string;
        properties?: Record<string, string | number | undefined>;
    };
    // (undocumented)
    export interface Variant {
        // (undocumented)
        enabled: boolean;
        // (undocumented)
        name: string;
        // (undocumented)
        payload?: Payload;
    }
    // (undocumented)
    export interface VariantDefinition {
        // (undocumented)
        name: string;
        // (undocumented)
        overrides: Override[];
        // (undocumented)
        payload: Payload;
        // (undocumented)
        weight: number;
    }
}

// @beta (undocumented)
export type IRolloutComponent = {
    isEnabled(name: string, context: IRolloutComponent.RolloutContext, fallbackFunction?: IRolloutComponent.FallbackFunction): boolean;
    getVariant(name: string, context: IRolloutComponent.RolloutContext, fallbackVariant?: IRolloutComponent.Variant): IRolloutComponent.Variant;
};

// @public (undocumented)
export interface ISlackComponent {
    // (undocumented)
    sendMessage(markdown: string): Promise<void>;
}

// @public
export interface IStatusCheckCapableComponent {
    readynessProbe?(): Promise<boolean>;
    startupProbe?(): Promise<boolean>;
}

// @public
export namespace Lifecycle {
    // (undocumented)
    export type ComponentBasedProgram<Components> = {
        stop(): Promise<void>;
        readonly components: Components;
    };
    // (undocumented)
    export type EntryPointParameters<Components> = ComponentBasedProgram<Components> & {
        startComponents(): Promise<void>;
    };
    export type ProgramConfig<Components> = {
        main: (program: EntryPointParameters<Components>) => Promise<any>;
        initComponents: () => Promise<Components>;
    };
    // @deprecated
    export function programEntryPoint<Components extends Record<string, any>>(config: {
        main: (components: Components) => Promise<any>;
        initComponents: () => Promise<Components>;
    }): Promise<ComponentBasedProgram<Components>>;
    export function run<Components extends Record<string, any>>(config: ProgramConfig<Components>): PromiseLike<ComponentBasedProgram<Components>>;
}


// (No @packageDocumentation comment for this package)

```
